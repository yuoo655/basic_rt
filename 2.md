二.内核参与调度协程的终极过程
当一个紧急事件出现时,如鼠标,键盘中断,内核中的中断处理函数,进入用户空间,再使它执行完当前协程后便主动让出,然后执行紧急协程.
注:
1.应用场景是高性能服务器,多为io密集型程序,执行当前协程不会花费很多时间.
2.好处为不需要保存状态.(因为协程是主动让出的). 
难点:被打断的协程没有执行完，直接进入了中断处理函数，此时它的执行状态还在栈上，如果不从中断处理函数返回，那它就没法执行了.
可能的处理方法:协程的执行器中有一个upcall_handler(类似内核中的syscall_handler).内核中的中断处理函数,会向用户发一个upcall.然后立即返回被打断的协程. 被打断的协程执行完当前协程之后便会检查是否有upcall. 如果有便做相应的处理.....这个处理具体长什么样还没想清楚.以及这些处理是否能在用户态运行